# 56.Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

 

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```





## Solution :

```java
class Solution {
    public int[][] merge(int[][] intervals) {
      	// sorting the intervals by the min order of left edge of each node.
        Arrays.sort(intervals, (a, b) -> {return a[0] - b[0];});
        
        int left = intervals[0][0];
        int right = intervals[0][1];
        List<int[]> res = new LinkedList<>();
        
        for (int i = 0; i < intervals.length; i++) {
          	// if current node's left edge bigger than we recorded the most right edge
          	// adding the current array to result and begin a new loop.
            if (intervals[i][0] > right) {
                res.add(new int[]{left, right});
                left = intervals[i][0];
                right = intervals[i][1];
            } else {
              	// updating the most right edge of current range.
                right = Math.max(right, intervals[i][1]);
            }
        }
        // adding the last date to result.
        res.add(new int[]{left, right});
        return res.toArray(new int[res.size()][]);
    }
}
```

